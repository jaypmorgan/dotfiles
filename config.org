#+TITLE: Emacs Config
#+AUTHOR: Jay Morgan

* Table of Contents :TOC:
- [[#executable-path][Executable Path]]
- [[#setup-package-environment][Setup Package Environment]]
  - [[#initialisation][Initialisation]]
  - [[#programming-modes][Programming Modes]]
  - [[#languageserver][LanguageServer]]
  - [[#org-mode-all-the-things][Org-mode all the things!]]
  - [[#miscellaneous-packages][Miscellaneous Packages]]
- [[#emacs-environment][Emacs Environment]]
- [[#keybindings][Keybindings]]
- [[#custom-functions][Custom Functions]]
- [[#email-client][Email Client]]
- [[#display-settings][Display Settings]]
  - [[#gui-elements][GUI Elements]]
  - [[#line-numbering][Line Numbering]]
  - [[#look--feel-theme][Look & Feel (Theme)]]
  - [[#splash-screen][Splash Screen]]

* Executable Path
There are a few directories I would like to include in the environment =PATH=
variable. This includes anything binary install via Anaconda (sometimes it can
be convenient), and fzf (though...I really don't use it, helm covers the
functionality pretty well).

#+BEGIN_SRC emacs-lisp
(defun my/add-to-exec (new-path)
  " Add the new-path (dir) to the PATH variable "
  (let ((new-path (expand-file-name new-path)))
  (setq exec-path (push new-path exec-path))
  (setenv "PATH" (format "%s:%s" (getenv "PATH") new-path))))

(my/add-to-exec "~/miniconda3/bin")
(my/add-to-exec "~/.fzf/bin")
(my/add-to-exec "~/.cargo/bin")
#+END_SRC
* Setup Package Environment
** Initialisation
Over the time of configuring Emacs, I've found these variables help certain
packages from creating speed problems.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 100000000)
(setq read-process-output-max (* 1024 1024))
(setq evil-want-keybinding nil)
(setq x-wait-for-event-timeout nil)
(setq tramp-ssh-controlmaster-options ""
      tramp-default-method "ssh")
#+END_SRC

A necessary configuration step of a customised Emacs setup is using melpa with
=package.el=.

#+BEGIN_SRC emacs-lisp
;; Manually installed plugins/packages
(add-to-list 'load-path (expand-file-name "~/.emacs.d/plugins/"))

;; Setup package.el to work with MELPA
(setq package-check-signature nil)
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
(add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))
(package-refresh-contents)
(package-initialize)
#+END_SRC

Most, if not all, packages are managed using the =use-package= plugin. This
should be the only plugin that is install in the "normal" fashion.

#+BEGIN_SRC emacs-lisp
;; Install function define a function to check if a package is
;; installed, if it not we can install it. From this, we may quickly
;; and easily install packages.
(defun my/check-and-install (pkg)
  (unless (package-installed-p pkg)
    (package-install pkg))
  (require pkg))

(my/check-and-install 'use-package)
;; Don't need a :ensure t in every package
(setq use-package-always-ensure t)
;; Makes it possible to install required binaries
(use-package use-package-ensure-system-package)
#+END_SRC

And quelpa

#+BEGIN_SRC emacs-lisp
(use-package quelpa)
(quelpa
 '(quelpa-use-package
   :fetcher git
   :url "https://github.com/quelpa/quelpa-use-package.git"))
(require 'quelpa-use-package)
#+END_SRC

** Programming Modes
It's a constant struggle to not learn every programming language ever!

Q: What are your favourite programming languages?\\
A: Clojure > Julia > C++ > Python

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :init
  (add-hook 'sh-mode-hook 'flycheck-mode))
(use-package clojure-mode :init (use-package cider))
(use-package markdown-mode)
(use-package htmlize)
(use-package toml-mode)

(use-package eglot
  :config
  (add-to-list 'eglot-server-programs '((c++-mode c-mode) "clangd"))
  (add-hook 'c++-mode-hook 'eglot-ensure))

(use-package python-mode
    :config
    (add-hook 'python-mode-hook (lambda ()
                                   (setq flycheck-pylintrc "/home/jaymorgan/.pylintrc")
                                   (setq flycheck-check-syntax-automatically '(mode-enabled save))
                                   (flycheck-mode)))
    (use-package conda
        :init
        (conda-env-initialize-eshell)
        (setq conda-anaconda-home (expand-file-name "~/miniconda3/")
              conda-env-home-directory (expand-file-name "~/miniconda3/"))))

(use-package julia-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.jmd\\'" . markdown-mode))
    (use-package julia-repl
        :quelpa ((julia-repl :fetcher github :repo "tpapp/julia-repl" :branch "tp/terminal-backends") :upgrade t)
        :init
        (add-hook 'julia-mode-hook 'julia-repl-mode)
        (setenv "JULIA_NUM_THREADS" "4")
        (setq julia-repl-executable-records
            '((default "julia")
                (master "/usr/bin/julia")
                (chemistry "ssh -t chemistry.me julia")
                (lis "ssh -t lis.me /home/jay.morgan/workspace/libs/julia/bin/julia")))))
#+END_SRC

** LanguageServer

#+BEGIN_SRC emacs-lisp
(use-package company
  :config
  (global-company-mode 1)
  (setq company-idle-delay 0.0001
        company-minimum-prefix-length 2
        company-show-numbers t))

(global-eldoc-mode -1)
#+END_SRC

** Org-mode all the things!
Once I learnt about org-mode, it would always be tough to leave Emacs.

#+BEGIN_SRC emacs-lisp
(use-package org
  :after cider
  :ensure org-plus-contrib
  :init
  (add-hook 'org-mode-hook #'visual-line-mode)
  (add-hook 'org-mode-hook '(lambda () (set-fill-column 70)))
  (add-hook 'org-mode-hook #'auto-fill-mode)
  (require 'ob-clojure)
  (require 'cider)
  ;; extensions on org-mode
  (use-package ob-async)
  (use-package ox-pandoc)
  (use-package ox-gfm)
  (use-package org-ref
    :init
    (setq reftex-default-bibliography "~/Dropbox/Notes/Wiki/library.bib"
          org-ref-default-bibliography '("~/Dropbox/Notes/Wiki/library.bib")))
  (use-package helm-bibtex
    :init
    (setq bibtex-completion-bibliography "~/Dropbox/Notes/Wiki/library.bib"
          bibtex-completion-pdf-open-function 'org-open-file))
  (add-to-list 'org-latex-packages-alist '("" "tikz" t))
  (add-to-list 'org-latex-compilers "tectonic")
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
  (eval-after-load "preview" '(add-to-list 'preview-default-preamble "\\PreviewEnvironment{tikzpicture}" t))

  (require 'ox-latex)

  ;; set variables
  (setq org-startup-indented t
        org-src-tab-acts-natively t
        org-edit-src-content-indentation 0
        org-startup-folded t
        org-format-latex-options (plist-put org-format-latex-options :scale 1.4)
        inferior-julia-program-name "/usr/bin/julia"
        org-confirm-babel-evaluate nil
        org-babel-clojure-backend 'cider
        org-fontify-done-headline t
        org-todo-keywords '((type "TODO(t)" "WAIT(w)" "|" "DONE(d)" "CANC(c)"))
        org-todo-keyword-faces '(("TODO" . org-warning)
                                 ("WAIT" . "yellow")
                                 ("DONE" . "Palegreen")
                                 ("CANC" . "red"))
        org-log-done 'time)

(custom-set-faces '(org-headline-done
                    ((((class color)
                       (min-colors 16)
                       (background dark))
                      (:foreground "dim gray" :strike-through t)))))

  ;; list of languages for org-mode to support
  (org-babel-do-load-languages 'org-babel-load-languages
                               '((shell . t)
                                 (emacs-lisp . t)
                                 (julia . t)
                                 (gnuplot . t)
                                 (dot . t))))
#+END_SRC

Sometimes it is nice to have a table of contents inside the org-mode document,
or in the rendered version on GitHub/Gitlab. With =toc-org= this is easily
possible.

#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :init
  (add-hook 'markdown-mode-hook 'toc-org-mode)
  (add-hook 'org-mode-hook 'toc-org-mode))
#+END_SRC

** Miscellaneous Packages

#+BEGIN_SRC emacs-lisp
(use-package docker :bind ("C-c d" . docker))
(use-package avy)
(use-package swiper)
(use-package itail)
(use-package diminish)
(use-package magit)
(use-package disable-mouse)
(use-package imenu-list)
(use-package linum-relative)
(use-package base16-theme)
(use-package ace-window)
(use-package focus)
(use-package iedit)

(use-package csv-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.csv\\'" . csv-align-mode)))

(use-package blacken
  :init
  (defun blacken-python-hook ()
    (when (eq major-mode 'python-mode)
      (blacken-buffer)))
  (add-hook 'before-save-hook 'blacken-python-hook))

(use-package yasnippet
  :init
  (use-package yasnippet-snippets
    :init
    (yas-global-mode 1))
  (yas-global-mode 1))

(use-package olivetti
  :init
  (setq olivetti-body-width 90)
  (defun set-editing-buffer ()
    (interactive)
    (set-window-fringes (selected-window) 0 0)
    (hl-line-mode -1))
  (add-hook 'olivetti-mode-hook 'set-editing-buffer))

(use-package pdf-tools
  :init
  (pdf-loader-install)
  (setq auto-revert-interval 0.5)
  (add-hook 'pdf-view-mode-hook (lambda () (linum-mode -1))))

(use-package flyspell
  :init
  (setq flyspell-default-dictionary "british"))

;; Prevent Helm from taking up random windows -- makes the UI more consistent
;; and predictable.
(use-package shackle
  :after helm
  :init
  (shackle-mode 1)
  (setq shackle-rules '(("\\`\\*helm.*?\\*\\'" :regexp t :align t :ratio 0.3))))
#+END_SRC

* Emacs Environment
A number of changes to the default config have been made to make the transition
from VIM to Emacs a little easier. First and foremost is =evil-mode=. Another
amendment is =evil-collection= with helps with propagating =evil-mode= to other
non-evil environments such as mu4e.

#+BEGIN_SRC emacs-lisp
(use-package evil
  :init
  (evil-mode 1))

(use-package evil-collection
  :after (evil)
  :config
  (evil-collection-init))
#+END_SRC

Keybindings are managed via =hydra=

#+BEGIN_SRC emacs-lisp
(use-package hydra)
#+END_SRC

It is unnecessary to say that Emacs comes with a whole load of keybindings,
=which-key= helps with easily being reminded.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :config
  (setq which-key-idle-delay 1)
  (which-key-mode 1))
#+END_SRC

A very simple modeline is configured with =doom-modeline=

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :init
  (doom-modeline-mode 1)
  (setq doom-modeline-height 10
        doom-modeline-mu4e t
        doom-modeline-icon nil))
#+END_SRC

Projects with =projectile=

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :config
  (projectile-mode 1)
  (setq projectile-git-submodule-command nil)
  (setq projectile-mode-line-function '(lambda () (format " Proj[%s]" (projectile-project-name))))
  (setq projectile-project-search-path '("~/workspace/")))
#+END_SRC


Workspaces are created using =eyebrowse=

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :config
  (eyebrowse-mode 1)
  ;; new workspaces are always empty
  (setq eyebrowse-new-workspace t))
#+END_SRC

The best terminal I've yet to come across, even if it doesn't have the elisp
bells & whistles that eshell does, is vterm

#+BEGIN_SRC emacs-lisp
(use-package vterm
  :commands (vterm vterm-other-window)
  :custom (vterm-kill-buffer-on-exit t))
#+END_SRC


And finally, helm for partial completions, searches, etc.

#+BEGIN_SRC emacs-lisp
(use-package helm
  :config
  (helm-mode 1)
  (use-package helm-projectile)
  (use-package helm-ag
    :ensure-system-package (ag . silversearcher-ag))
  (setq helm-use-frame-when-more-than-two-windows nil
        helm-split-window-in-side nil
        helm-display-function 'pop-to-buffer
        helm-idle-delay 0.0
        helm-input-idle-delay 0.01))
#+END_SRC
* Keybindings

#+BEGIN_SRC emacs-lisp
(require 'hydra)
(require 'evil)
(require 'ace-window)
(define-key evil-motion-state-map " " nil)
(global-set-key (kbd "M-x") 'helm-M-x)

(add-hook 'mu4e-main-mode-hook '(lambda () (interactive) (linum-mode -1)))

(defun my/queue ()
  "run slurm's squeue command. Using eshell should run it on the
   server if invoked in tramp buffer"
  (interactive)
  (eshell-command "squeue"))

(defun my/bash ()
  "start a (or connect to existing) terminal emulator in a new window"
  (interactive)
  (split-window-below)
  (other-window 1)
  (if (get-buffer "vterm")
      (progn
        (switch-to-buffer "vterm")
        (shrink-window 10))
    (vterm)))

(defvar dark-theme-p t)
(defun my/toggle-theme ()
  (interactive)
  (let ((light-theme 'base16-default-light)
        (dark-theme 'base16-espresso))
    (if (eq dark-theme-p t)
        (progn
          (load-theme light-theme t)
          (setq dark-theme-p -1))
      (progn
        (load-theme dark-theme t)
        (setq dark-theme-p t)))))

(defmacro bind-evil-key (binding func)
  `(define-key evil-motion-state-map (kbd ,binding) (quote ,func)))

(defmacro bind-global-key (binding func)
  `(global-set-key (kbd ,binding) (quote, func)))

(with-eval-after-load 'evil-maps
  (define-key evil-normal-state-map (kbd "C-n") nil))
(bind-evil-key "C-n"
  (lambda ()
    (interactive)
    (iedit-mode)
    (iedit-restrict-current-line)))

(bind-evil-key "SPC g d" elpy-goto-definition)

(defhydra hydra-helm-files (:color blue :hint nil)
  "Helm Files"
  ("f" helm-find-files "Find Files")
  ("r" helm-recentf "File Recent Files")
  ("b" swiper "Find in buffer"))
(bind-evil-key "SPC f" hydra-helm-files/body)

(defhydra hydra-helm (:color blue :hint nil)
  "Helm"
  ("r" helm-regexp "Regex")
  ("i" helm-imenu "Imenu")
  ("f" helm-find "Find")
  ("g" helm-do-ag "AG Search"))
(bind-evil-key "SPC h" hydra-helm/body)

(bind-evil-key "SPC p" projectile-command-map)
(bind-evil-key "SPC p p" helm-projectile-switch-project)
(bind-evil-key "SPC p a" projectile-add-known-project)
(bind-evil-key "SPC g g" magit-status)
(bind-evil-key "SPC a" org-agenda)
(bind-evil-key "SPC w" ace-window)
(bind-evil-key "SPC n" avy-goto-char-timer)
(bind-evil-key "SPC e" eww)
(bind-global-key "C-x ," vterm) ;; new terminal in window

(defun my/split (direction)
  (interactive)
  (let ((p-name (projectile-project-name)))
    (if (string-equal direction "vertical")
        (evil-window-vsplit)
      (evil-window-split))
    (other-window 1)
    (if p-name
        (helm-projectile-find-file)
      (switch-to-buffer "*scratch*"))))

(bind-evil-key "SPC s v" (lambda () (interactive) (my/split "vertical")))
(bind-evil-key "SPC s h" (lambda () (interactive) (my/split "horizontal")))

(defhydra hydra-eyebrowse (:color blue :hint nil)
  "Workspaces"
  ("s" eyebrowse-switch-to-window-config "Show workspaces")
  ("1" eyebrowse-switch-to-window-config-1 "Workspace 1")
  ("2" eyebrowse-switch-to-window-config-2 "Workspace 2")
  ("3" eyebrowse-switch-to-window-config-3 "Workspace 3")
  ("4" eyebrowse-switch-to-window-config-4 "Workspace 4")
  ("5" eyebrowse-switch-to-window-config-5 "Workspace 5")
  ("6" eyebrowse-switch-to-window-config-6 "Workspace 6")
  ("7" eyebrowse-switch-to-window-config-7 "Workspace 7")
  ("8" eyebrowse-switch-to-window-config-8 "Workspace 8")
  ("9" eyebrowse-switch-to-window-config-9 "Workspace 9"))
(define-key evil-motion-state-map
  (kbd "SPC TAB") 'hydra-eyebrowse/body)

(define-key evil-motion-state-map
  (kbd "SPC SPC") 'helm-buffers-list)

(defhydra hydra-openbuffer (:color blue :hint nil)
  "Open Buffer"
  ("s" my/bash "Shell")
  ("S" vterm "Big Shell")
  ("d" (progn (split-window-sensibly) (dired-at-point ".")) "Dired in another window")
  ("D" (dired-at-point ".") "Dired")
  ("c" (find-file "~/.emacs.d/config.org") "Open Emacs Config")
  ("t" (find-file "~/Dropbox/Notes/tasks.org") "Open tasks")
  ("i" imenu-list-smart-toggle "Open Menu Buffer")
  ("u" undo-tree-visualize "Undo-tree")
  ("m" mu4e "Open Mailbox"))
(define-key evil-motion-state-map
  (kbd "SPC o") 'hydra-openbuffer/body)

(defhydra hydra-insert (:color blue :hint nil)
  "Insert into Buffer"
  ("s" yas-insert-snippet "Insert Snippet"))
(define-key evil-motion-state-map
  (kbd "SPC i") 'hydra-insert/body)

(defhydra hydra-remote-hosts (:color blue :hint nil)
  "Browse remote hosts"
  ("l" (dired-at-point "/ssh:lis.me:~/workspace") "LIS Lab")
  ("s" (dired-at-point "/ssh:sunbird.me:~/workspace") "Sunbird Swansea")
  ("i" (dired-at-point "/ssh:ibex.me:~") "KAUST Ibex")
  ("c" (dired-at-point "/ssh:chemistry.me:~/workspace") "Chemistry Swanasea"))
(define-key evil-motion-state-map
  (kbd "SPC r") 'hydra-remote-hosts/body)

(defhydra hydra-modify-buffers (:color blue :hint nil)
  "Modify buffer"
  ("w" (write-file (buffer-file-name)) "Write")
  ("o" olivetti-mode "Olivetti Mode")
  ("b" ibuffer "Edit Buffers")
  ("q" (kill-buffer-and-window) "Close"))
(define-key evil-motion-state-map
  (kbd "SPC m") 'hydra-modify-buffers/body)
#+END_SRC

* Custom Functions

#+BEGIN_SRC elisp
(defun get-stats (user host format)
  (eshell-command-result
   (concat
    "cd /ssh:" host ":/ && sacct -u" user " --format=" format)))

(defun slurm-get-stats (user host format)
  " Log into SLURM server and get current running/pending jobs "
  (interactive)
  (let ((stats (get-stats user host format))
        (temp-buffer-name "*slurm-log*"))
    (display-buffer
        (get-buffer-create temp-buffer-name)
        '((display-buffer-below-selected display-buffer-at-bottom)
          (inhibit-same-window . t)
          (window-height . 20)))
    (switch-to-buffer-other-window temp-buffer-name)
    (insert stats)
    (special-mode)))

(setq slurm-host "lis.me"
      slurm-username "jay.morgan"
      slurm-job-format "jobid,jobname%30,state,elapsed")

(bind-evil-key "SPC l l" (lambda ()
                           (interactive)
                           (slurm-get-stats  slurm-username
                                            slurm-host
                                            slurm-job-format)))
#+END_SRC
* Email Client
I use mu4e and offlinemap to manage my email.

For the most part, the mu4e configuration is as default. The exception to this
is to use the =mail-add-attachment= function that doesn't prompt for the type of
file you're trying to attach. The second is =org-store-link= which allows me to
easily reference the email from my TODO list.

#+BEGIN_SRC emacs-lisp
(when (file-exists-p "/usr/local/share/emacs/site-lisp/mu4e/mu4e.el")
  (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e/")
  ;; define some custom keybindings
  (require 'mu4e)
  (define-key mu4e-compose-mode-map (kbd "C-c C-a") 'mail-add-attachment)
  (define-key mu4e-view-mode-map (kbd "C-c C-s") 'org-store-link)
  ;; load the configuration details
  (when (file-exists-p "~/.emacs.d/mu4e-init.el")
      (load "~/.emacs.d/mu4e-init.el")))

(use-package mu4e-alert
  :init
  (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display))
#+END_SRC

* Display Settings
** GUI Elements
Keep the frame clean by removing all such GUI elements.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

Disable mouse!!\\
While it may be nice to use the mouse, I find it more preferable to use emacs as
a 'cmd-line' application, rather than graphical point-and-click. I use
disable-mouse package to disable all mouse operations in evil mode.

#+BEGIN_SRC emacs-lisp
(global-disable-mouse-mode)
(mapc #'disable-mouse-in-keymap
  (list evil-motion-state-map
        evil-normal-state-map
        evil-visual-state-map
        evil-insert-state-map))
#+END_SRC

** Line Numbering
#+BEGIN_SRC emacs-lisp
(global-linum-mode)
(linum-relative-on)
#+END_SRC

** Look & Feel (Theme)

#+BEGIN_SRC emacs-lisp
(add-to-list 'custom-theme-load-path "~/.emacs.d/themes/")
(load-theme 'base16-espresso t)
(set-frame-font "Tamsyn-11")
(setq default-frame-alist '((font . "JetBrains Mono-10")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-alh")
(global-auto-revert-mode t)
(setq completion-auto-help t)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)

(setq-default indent-tabs-mode nil)
(setq tab-stop 4)

;; Remove line continue character
(setf (cdr (assq 'continuation fringe-indicator-alist))
      '(nil nil) ;; no continuation indicators
      ;; '(nil right-curly-arrow) ;; right indicator only
      ;; '(left-curly-arrow nil) ;; left indicator only
      ;; '(left-curly-arrow right-curly-arrow) ;; default
      )

(setq auto-save-default nil)
(setq backup-directory-alist '(("" . "~/.Trash")))
(put 'dired-find-alternate-file 'disabled nil)
(setq confirm-kill-processes nil)

(defalias 'yes-or-no-p 'y-or-n-p)
(setq revert-without-query 1)

;; Close the compilation window if there was no error at all.
(setq compilation-exit-message-function
    (lambda (status code msg)
        ;; If M-x compile exists with a 0
        (when (and (eq status 'exit) (zerop code))
        ;; then bury the *compilation* buffer, so that C-x b doesn't go there
        (bury-buffer "*compilation*")
        ;; and return to whatever were looking at before
        (replace-buffer-in-windows "*compilation*"))
        ;; Always return the anticipated result of compilation-exit-message-function
    (cons msg code)))

(recentf-mode 1)
(setq recentf-max-menu 50
      recentf-max-saved-items 50)

(global-prettify-symbols-mode +1)
#+END_SRC

** Splash Screen
In my workflow, I don't find the splash screen useful, thus I prefer to supress
it and use the scratch buffer as the initial state.

#+BEGIN_SRC emacs-lisp
(setq-default inhibit-startup-screen t)
(setq inhibit-splash-screen t)
(setq inhibit-startup-message t)
(setq initial-scratch-message "")
#+END_SRC
