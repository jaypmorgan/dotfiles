#+TITLE: Emacs Config
#+AUTHOR: Jay Morgan
#+options: toc:nil
#+property: header-args :tangle yes

# Local Variables:
# eval: (add-hook 'after-save-hook (lambda nil (org-babel-tangle)) nil t)
# End:

* Table of Contents                                                     :TOC:
- [[#executable-path][Executable Path]]
- [[#setup-package-environment][Setup Package Environment]]
  - [[#initialisation][Initialisation]]
  - [[#programming-modes][Programming Modes]]
  - [[#languageserver][LanguageServer]]
  - [[#org-mode-all-the-things][Org-mode all the things!]]
  - [[#miscellaneous-packages][Miscellaneous Packages]]
- [[#emacs-environment][Emacs Environment]]
- [[#keybindings][Keybindings]]
- [[#custom-functions][Custom Functions]]
- [[#email-client][Email Client]]
- [[#display-settings][Display Settings]]
  - [[#gui-elements][GUI Elements]]
  - [[#line-numbering][Line Numbering]]
  - [[#look--feel-theme][Look & Feel (Theme)]]
  - [[#splash-screen][Splash Screen]]

* Executable Path
There are a few directories I would like to include in the environment =PATH=
variable. This includes anything binary install via Anaconda (sometimes it can be
convenient), and fzf (though...I really don't use it, helm covers the functionality
pretty well).

#+BEGIN_SRC emacs-lisp
(defun my/add-to-exec (new-path)
  " Add the new-path (dir) to the PATH variable "
  (let ((new-path (expand-file-name new-path)))
    (setq exec-path (push new-path exec-path))
    (setenv "PATH" (format "%s:%s" (getenv "PATH") new-path))))

(my/add-to-exec "~/miniconda3/bin")
(my/add-to-exec "~/.fzf/bin")
(my/add-to-exec "~/.cargo/bin")
#+END_SRC

* Setup Package Environment
** Initialisation

First, we bootstrap =straight.el= to compile native machine code, and install
=use-package= to call =straight.el=.

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(straight-use-package 'use-package)
(setq straight-use-package-by-default t)
(add-to-list 'load-path (expand-file-name "~/.emacs.d/plugins/"))
#+end_src

Over the time of configuring Emacs, I've found these variables help certain
packages from creating speed problems.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 100000000
      read-process-output-max (* 1024 1024)
      evil-want-keybinding nil
      x-wait-for-event-timeout nil
      tramp-ssh-controlmaster-options ""
      tramp-default-method "ssh")
#+END_SRC

A necessary configuration step of a customised Emacs setup is using melpa with
=package.el=.

And quelpa

#+BEGIN_SRC emacs-lisp
(use-package quelpa)
(quelpa
 '(quelpa-use-package
   :fetcher git
   :url "https://github.com/quelpa/quelpa-use-package.git"))
(require 'quelpa-use-package)
#+END_SRC

** Programming Modes
It's a constant struggle to not learn every programming language ever!

Q: What are your favourite programming languages?\\
A: Clojure > Julia > C++ > Python

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :init
  (add-hook 'sh-mode-hook 'flycheck-mode))
(use-package clojure-mode :init (use-package cider))
(use-package markdown-mode)
(use-package htmlize)
(use-package toml-mode)
(use-package haskell-mode)

(use-package eglot
  :config
  (add-to-list 'eglot-server-programs '((c++-mode c-mode) "clangd"))
  (add-hook 'c++-mode-hook 'eglot-ensure))

(use-package python-mode
    :config
    (setq python-shell-interpreter "ipython"
          python-shell-interpreter-args "-i")
    (use-package anaconda-mode)
    (use-package blacken
    :init
    (defun blacken-python-hook ()
        (when (eq major-mode 'python-mode)
        (blacken-buffer)))
    (add-hook 'before-save-hook 'blacken-python-hook))
    (use-package conda
        :init
        (conda-env-initialize-eshell)
        (setq conda-anaconda-home (expand-file-name "~/miniconda3/")
              conda-env-home-directory (expand-file-name "~/miniconda3/"))))

(use-package julia-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.jmd\\'" . markdown-mode))
    (use-package julia-repl
        :quelpa ((julia-repl :fetcher github :repo "tpapp/julia-repl" :branch "tp/terminal-backends") :upgrade t)
        :init
        (add-hook 'julia-mode-hook 'julia-repl-mode)
        (setenv "JULIA_NUM_THREADS" "4")
        (setq julia-repl-executable-records
            '((default "julia")
                (master "/usr/bin/julia")
                (chemistry "ssh -t chemistry.me julia")
                (lis "ssh -t lis.me ~/workspace/libs/julia/bin/julia")))))
#+END_SRC

** LanguageServer

Use company-mode for completion at point and company box to improve the UI of the completion list in
prog-modes.

#+BEGIN_SRC emacs-lisp
(use-package company
  :hook (prog-mode . company-mode)
  :config
  (setq company-idle-delay 0.0000001
        company-minimum-prefix-length 2
        company-candidates-cache t))

(use-package company-box
  :hook (company-mode . company-box-mode))
#+END_SRC

For our programming buffers, I use =lsp-mode= to connect to a specific LanguageServer.

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :hook ((python-mode . lsp-deferred)
         (julia-mode . lsp-deferred))
  :commands (lsp lsp-deferred)
  :init
  (setq lsp-keymap-prefix "C-c l")
  (setq lsp-disabled-clients '(mypls)))
#+END_SRC

** Org-mode all the things!
Once I learnt about org-mode, it would always be tough to leave Emacs.

#+BEGIN_SRC emacs-lisp
  (straight-override-recipe
     '(org :type git :host github :repo "emacsmirror/org" :no-build t))
  (use-package org
    :ensure t
    :ensure org-plus-contrib
    :init
    (add-hook 'org-mode-hook '(lambda ()
                                (set-fill-column 85)
                                (visual-line-mode 1)
                                (auto-fill-mode 1)))
    (require 'ob-clojure)
    (require 'ox-latex)
    (require 'cider)

    (use-package ox-latex-subfigure
      :load-path "plugins/ox-latex-subfigure"
      :init
      (setq org-latex-prefer-user-labels t)
      :config (require 'ox-latex-subfigure))
    (use-package ox-pandoc)
    (use-package ox-gfm)
    (use-package ess)

    (use-package org-ref
      :init
      (setq reftex-default-bibliography "~/Dropbox/Notes/Wiki/library.bib"
            org-ref-default-bibliography '("~/Dropbox/Notes/Wiki/library.bib")))

    (use-package helm-bibtex
      :init
      (setq bibtex-completion-bibliography "~/Dropbox/Notes/Wiki/library.bib"
            bibtex-completion-pdf-open-function 'org-open-file))

    ;; enable tikzpictures in latex export
    (add-to-list 'org-latex-packages-alist '("" "tikz" t))
    (eval-after-load "preview" '
      (add-to-list 'preview-default-preamble "\\PreviewEnvironment{tikzpicture}" t))

    ;; set variables
    (setq org-startup-indented t
          org-startup-folded t
          org-src-tab-acts-natively t
          org-hide-leading-stars t
          org-image-actual-width nil
          org-edit-src-content-indentation 0
          org-latex-listings 'minted   ;; color highlighting for source blocks
          org-latex-packages-alist '(("" "minted"))
          org-latex-pdf-process '( "latexmk -shell-escape -bibtex -f -pdf %f")
          ;; org-latex-pdf-process
          ;;     '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          ;;     "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")
          org-format-latex-options (plist-put org-format-latex-options :scale 1.4)
          inferior-julia-program-name "/usr/bin/julia"
          org-babel-clojure-backend 'cider
          org-confirm-babel-evaluate nil
          org-fontify-done-headline t
          org-log-done 'time
          org-todo-keywords '((type "TODO(t)" "WAIT(w)" "|" "DONE(d)" "CANC(c)"))
          org-todo-keyword-faces '(("TODO" . org-warning)
                                   ("WAIT" . "yellow")
                                   ("DONE" . "Palegreen")
                                   ("CANC" . "red")))

      (add-to-list 'org-latex-classes
              '("book-no-parts"
                  "\\documentclass{book}"
                  ("\\chapter{%s}" . "\\chapter*{%s}")
                  ("\\section{%s}" . "\\section*{%s}")
                  ("\\subsection{%s}" . "\\subsection*{%s}")
                  ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                  ("\\paragraph{%s}" . "\\paragraph*{%s}")))
    (custom-set-faces '(org-headline-done
                          ((((class color)
                          (min-colors 16)
                          (background dark))
                          (:foreground "dim gray" :strike-through t)))))

    ;; list of languages for org-mode to support
    (org-babel-do-load-languages 'org-babel-load-languages
                                 '((shell . t)
                                   (python . t)
                                   (clojure . t)
                                   (R . t)
                                   (emacs-lisp . t)
                                   (gnuplot . t)
                                   (dot . t))))
#+END_SRC

Sometimes it is nice to have a table of contents inside the org-mode document,
or in the rendered version on GitHub/Gitlab. With =toc-org= this is easily
possible.

#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :init
  (add-hook 'markdown-mode-hook 'toc-org-mode)
  (add-hook 'org-mode-hook 'toc-org-mode))
#+END_SRC

** Miscellaneous Packages

#+BEGIN_SRC emacs-lisp
(use-package avy)
(use-package swiper)
(use-package itail)
(use-package magit)
(use-package disable-mouse)
(use-package imenu-list)
(use-package linum-relative)
(use-package ace-window)
(use-package focus)
(use-package iedit)
(use-package ripgrep)

(use-package elfeed
  :init
  (use-package elfeed-org
    :config
    (elfeed-org)
    (setq rmh-elfeed-org-files '("~/Dropbox/Notes/feeds.org"))))

(use-package undo-tree
  :init
  (setq undo-tree-visualizer-timestamps t)
  (global-undo-tree-mode))

(use-package csv-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.csv\\'" . csv-align-mode)))

(use-package yasnippet
  :init
  (use-package yasnippet-snippets
    :init
    (yas-global-mode 1))
  (yas-global-mode 1))

(use-package olivetti
  :init
  (setq olivetti-body-width 90)
  (defun set-editing-buffer ()
    (interactive)
    (linum-mode -1)
    (set-window-fringes (selected-window) 0 0)
    (hl-line-mode -1))
  (add-hook 'olivetti-mode-hook 'set-editing-buffer))

(use-package pdf-tools
  :init
  (pdf-loader-install)
  (setq auto-revert-interval 0.5)
  (add-hook 'pdf-view-mode-hook (lambda () (linum-mode -1))))

(use-package flyspell
  :init
  (setq flyspell-default-dictionary "british"))

;; Prevent Helm from taking up random windows -- makes the UI more consistent
;; and predictable.
(use-package shackle
  :after helm
  :init
  (shackle-mode 1)
  (setq shackle-rules '(("\\`\\*helm.*?\\*\\'" :regexp t :align t :ratio 0.3))))
#+END_SRC

* Emacs Environment
A number of changes to the default config have been made to make the transition
from VIM to Emacs a little easier. First and foremost is =evil-mode=. Another
amendment is =evil-collection= with helps with propagating =evil-mode= to other
non-evil environments such as mu4e.

#+BEGIN_SRC emacs-lisp
(use-package evil
  :init
  (evil-mode 1))

(use-package evil-collection
  :after (evil)
  :config
  (evil-collection-init))
#+END_SRC

Keybindings are managed via =hydra=

#+BEGIN_SRC emacs-lisp
(use-package hydra)
#+END_SRC

It is unnecessary to say that Emacs comes with a whole load of keybindings,
=which-key= helps with easily being reminded.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :config
  (setq which-key-idle-delay 1)
  (which-key-mode 1))
#+END_SRC

A very simple modeline is configured with =doom-modeline=

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :init
  (doom-modeline-mode 1)
  (setq doom-modeline-height 10
        doom-modeline-mu4e t
        doom-modeline-icon nil
        doom-modeline-env-enable-python t))
#+END_SRC

Projects with =projectile=

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :config
  (projectile-mode 1)
  (setq projectile-git-submodule-command nil)
  (setq projectile-mode-line-function '(lambda () (format " Proj[%s]" (projectile-project-name))))
  (setq projectile-project-search-path '("~/workspace/")))

;; group buffers from the same projectile project
(use-package ibuffer-vc
  :init
  (defun my/ibuffer-hook ()
    (interactive)
    (ibuffer-vc-generate-filter-groups-by-vc-root))
  (add-hook 'ibuffer-mode-hook 'my/ibuffer-hook))
#+END_SRC

Workspaces are created using =eyebrowse=

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :config
  (eyebrowse-mode 1)
  ;; new workspaces are always empty
  (setq eyebrowse-new-workspace t))
#+END_SRC

The best terminal I've yet to come across, even if it doesn't have the elisp
bells & whistles that eshell does, is vterm

#+BEGIN_SRC emacs-lisp
(use-package vterm
  :commands (vterm vterm-other-window)
  :custom (vterm-kill-buffer-on-exit t)
  :init
  (add-hook 'vterm-mode-hook (lambda () (linum-mode -1)))
  (add-hook 'vterm-mode-hook (lambda () (company-mode -1)))
  (setq term-prompt-regexp "^[^#$%>\n]*$ *"))
#+END_SRC

And finally, helm for partial completions, searches, etc.

#+BEGIN_SRC emacs-lisp
(use-package helm
  :config
  (helm-mode 1)
  (use-package helm-projectile)
  (setq helm-use-frame-when-more-than-two-windows nil
        helm-split-window-in-side nil
        helm-display-function 'pop-to-buffer
        helm-idle-delay 0.0
        helm-input-idle-delay 0.01))
#+END_SRC

* Keybindings

#+BEGIN_SRC emacs-lisp
(require 'hydra)
(require 'evil)
(require 'ace-window)
(define-key evil-motion-state-map " " nil)
(global-set-key (kbd "M-x") 'helm-M-x)

(define-key org-mode-map (kbd "C-c C-c")
  (lambda () (interactive) (org-ctrl-c-ctrl-c)
                           (org-display-inline-images)))

(defun my/queue ()
  "run slurm's squeue command. Using eshell should run it on the
   server if invoked in tramp buffer"
  (interactive)
  (eshell-command "squeue"))

(defun my/bash ()
  "start a (or connect to existing) terminal emulator in a new window"
  (interactive)
  (split-window-below)
  (other-window 1)
  (if (get-buffer "vterm")
      (progn
        (switch-to-buffer "vterm")
        (shrink-window 10))
    (vterm)))

(defvar dark-theme-p t)
(defun my/toggle-theme ()
  (interactive)
  (let ((light-theme 'modus-operandi)
        (dark-theme 'atom-one-dark))
    (if (eq dark-theme-p t)
        (progn
          (load-theme light-theme t)
          (setq dark-theme-p -1))
      (progn
        (load-theme dark-theme t)
        (setq dark-theme-p t)))))

(defmacro bind-evil-key (binding func)
  `(define-key evil-motion-state-map (kbd ,binding) (quote ,func)))

(defmacro bind-global-key (binding func)
  `(global-set-key (kbd ,binding) (quote, func)))

(with-eval-after-load 'evil-maps
  (define-key evil-normal-state-map (kbd "C-n") nil))
(bind-evil-key "C-n"
  (lambda ()
    (interactive)
    (iedit-mode)
    (iedit-restrict-current-line)))

(bind-evil-key "SPC g d" elpy-goto-definition)
(bind-global-key "C-/" (lambda () (interactive) (comment-or-uncomment-region (line-beginning-position) (line-end-position))))

(defhydra hydra-helm-files (:color blue :hint nil)
  "Helm Files"
  ("f" helm-find-files "Find Files")
  ("r" helm-recentf "File Recent Files")
  ("b" swiper "Find in buffer"))
(bind-evil-key "SPC f" hydra-helm-files/body)

(defhydra hydra-helm (:color blue :hint nil)
  "Helm"
  ("r" helm-regexp "Regex")
  ("i" helm-imenu "Imenu")
  ("f" helm-find "Find")
  ("g" helm-do-ag "AG Search"))
(bind-evil-key "SPC h" hydra-helm/body)

(bind-evil-key "SPC p" projectile-command-map)
(bind-evil-key "SPC p p" helm-projectile-switch-project)
(bind-evil-key "SPC p a" projectile-add-known-project)
(bind-evil-key "SPC g g" magit-status)
(bind-evil-key "SPC a" org-agenda)
(bind-evil-key "SPC w" ace-window)
(bind-evil-key "SPC n" avy-goto-char-timer)
(bind-evil-key "SPC e" eww)
(bind-global-key "C-x ," vterm) ;; new terminal in window

(defun my/split (direction)
  (interactive)
  (let ((p-name (projectile-project-name)))
    (if (string= direction "vertical")
        (evil-window-vsplit)
      (evil-window-split))
    (other-window 1)
    (if p-name
        (helm-projectile-find-file)
      (switch-to-buffer "*scratch*"))))

(bind-evil-key "SPC s v" (lambda () (interactive) (my/split "vertical")))
(bind-evil-key "SPC s h" (lambda () (interactive) (my/split "horizontal")))

(defhydra hydra-eyebrowse (:color blue :hint nil)
  "Workspaces"
  ("s" eyebrowse-switch-to-window-config "Show workspaces")
  ("1" eyebrowse-switch-to-window-config-1 "Workspace 1")
  ("2" eyebrowse-switch-to-window-config-2 "Workspace 2")
  ("3" eyebrowse-switch-to-window-config-3 "Workspace 3")
  ("4" eyebrowse-switch-to-window-config-4 "Workspace 4")
  ("5" eyebrowse-switch-to-window-config-5 "Workspace 5")
  ("6" eyebrowse-switch-to-window-config-6 "Workspace 6")
  ("7" eyebrowse-switch-to-window-config-7 "Workspace 7")
  ("8" eyebrowse-switch-to-window-config-8 "Workspace 8")
  ("9" eyebrowse-switch-to-window-config-9 "Workspace 9"))
(bind-evil-key "SPC TAB" hydra-eyebrowse/body)

(bind-evil-key "SPC SPC" helm-buffers-list)

(defhydra hydra-open-config (:color blue :hint nil)
  "Open Config"
  ("e" (find-file "~/.emacs.d/config.org") "Emacs Config")
  ("x" (find-file "~/.xmonad/xmonad.hs") "Xmonad Config"))

(defhydra hydra-openbuffer (:color blue :hint nil)
  "Open Buffer"
  ("c" hydra-open-config/body "Config files")
  ("d" (progn (split-window-sensibly) (dired-jump)) "Dired in another window")
  ("D" (dired-jump) "Dired")
  ("e" elfeed "Elfeed")
  ("i" imenu-list-smart-toggle "Open Menu Buffer")
  ("m" mu4e "Open Mailbox")
  ("s" my/bash "Shell")
  ("S" vterm "Big Shell")
  ("t" (find-file "~/Dropbox/Notes/tasks.org") "Open tasks")
  ("u" undo-tree-visualize "Undo-tree"))
(bind-evil-key "SPC o" hydra-openbuffer/body)

(defhydra hydra-insert (:color blue :hint nil)
  "Insert into Buffer"
  ("s" yas-insert-snippet "Insert Snippet"))
(bind-evil-key "SPC i" hydra-insert/body)

(defhydra hydra-remote-hosts (:color blue :hint nil)
  "Browse remote hosts"
  ("l" (dired-at-point "/ssh:lis.me:~/workspace") "LIS Lab")
  ("s" (dired-at-point "/ssh:sunbird.me:~/workspace") "Sunbird Swansea")
  ("i" (dired-at-point "/ssh:ibex.me:~") "KAUST Ibex")
  ("c" (dired-at-point "/ssh:chemistry.me:~/workspace") "Chemistry Swanasea"))
(bind-evil-key "SPC r" hydra-remote-hosts/body)

(defhydra hydra-modify-buffers (:color blue :hint nil)
  "Modify buffer"
  ("w" (write-file (buffer-file-name)) "Write")
  ("o" olivetti-mode "Olivetti Mode")
  ("b" ibuffer "Edit Buffers")
  ("q" (kill-buffer-and-window) "Close"))
(bind-evil-key "SPC m" hydra-modify-buffers/body)
#+END_SRC

* Custom Functions

#+BEGIN_SRC emacs-lisp
(defun get-stats (user host format)
  "Get SLURM status from remote server"
  (eshell-command-result
   (concat
    "cd /ssh:" host ":/ && sacct -u" user " --format=" format)))

(defun slurm-get-stats (user host format)
  "Log into SLURM server and get current running/pending jobs"
  (interactive)
  (let ((stats (get-stats user host format))
        (temp-buffer-name "*slurm-log*"))
    (display-buffer
        (get-buffer-create temp-buffer-name)
        '((display-buffer-below-selected display-buffer-at-bottom)
          (inhibit-same-window . t)
          (window-height . 20)))
    (switch-to-buffer-other-window temp-buffer-name)
    (insert stats)
    (special-mode)))

(setq slurm-host "lis.me"
      slurm-username "jay.morgan"
      slurm-job-format "jobid,jobname%30,state,elapsed")

(bind-evil-key "SPC l l" (lambda ()
                           (interactive)
                           (slurm-get-stats slurm-username
                                            slurm-host
                                            slurm-job-format)))

;; Projectile level syncing between local and remote hosts
;; set the initial variables to nil
;; .dir-local.el should set these at a project level
(setq rsync-source nil
      rsync-destination nil)

(defun dorsync (src dest)
  "Launch an asynchronuous rsync command"
  (interactive)
  (let ((async-value async-shell-command-display-buffer))
    (setq async-shell-command-display-buffer nil)
    (async-shell-command (concat "rsync -a " src " " dest))
    (setq async-shell-command-display-buffer async-value)))

;; Bind a local key to launch rsync
(bind-evil-key "SPC l ;" (lambda ()
                           (interactive)
                           (dorsync rsync-source rsync-destination)))
#+END_SRC

* Email Client
I use mu4e and offlinemap to manage my email.

For the most part, the mu4e configuration is as default. The exception to this is to
use the =mail-add-attachment= function that doesn't prompt for the type of file
you're trying to attach. The second is =org-store-link= which allows me to easily
reference the email from my TODO list.

#+BEGIN_SRC emacs-lisp
(when (file-exists-p "/usr/local/share/emacs/site-lisp/mu4e/mu4e.el")
  (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e/")
  ;; define some custom keybindings
  (require 'mu4e)
  (define-key mu4e-compose-mode-map (kbd "C-c C-a") 'mail-add-attachment)
  (define-key mu4e-view-mode-map (kbd "C-c C-s") 'org-store-link)
  ;; load the configuration details
  (when (file-exists-p "~/.emacs.d/mu4e-init.el")
    (load "~/.emacs.d/mu4e-init.el")
    (add-hook 'mu4e-main-mode-hook '(lambda () (interactive) (linum-mode -1)))))

(use-package mu4e-alert
  :init
  (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display))
#+END_SRC

* Display Settings
** GUI Elements
Keep the frame clean by removing all such GUI elements.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

Disable mouse!!\\
While it may be nice to use the mouse, I find it more preferable to use emacs as a
'cmd-line' application, rather than graphical point-and-click. I use disable-mouse
package to disable all mouse operations in evil mode.

#+BEGIN_SRC emacs-lisp
(global-disable-mouse-mode)
(mapc #'disable-mouse-in-keymap
  (list evil-motion-state-map
        evil-normal-state-map
        evil-visual-state-map
        evil-insert-state-map))
#+END_SRC

** Line Numbering
#+BEGIN_SRC emacs-lisp
(global-linum-mode)
(linum-relative-on)
#+END_SRC

** Look & Feel (Theme)

To begin, let's set a color scheme and font face.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'custom-theme-load-path "~/.emacs.d/themes/")

  (use-package base16-theme)
  (use-package modus-vivendi-theme)
  (use-package modus-operandi-theme
    :init
    (setq modus-operandi-theme-org-blocks 'grayscale
	  modus-operandi-theme-mode-line 'moody)
    (set-face-attribute 'default nil :family "Lilex Regular" :height 110)
    (set-face-attribute 'variable-pitch nil :family "Open Sans" :height 1.0)
    (set-face-attribute 'fixed-pitch nil :family "Lilex Regular" :height 1.0))

  (load-theme 'modus-operandi t)
  (set-face-attribute 'default nil :font "Lilex-12.5")
  (setq default-frame-alist '((font . "Lilex-12.5")))

  ;; Enable font ligatures. If the font-face does not support any element in the
  ;; list of ligatures, emacs may stall...
  (straight-use-package
   '(ligature :type git :host github :repo "mickeynp/ligature.el"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
(setq completion-auto-help t)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
(add-hook 'image-mode-hook (lambda () (linum-mode -1)))

(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)

(setq-default indent-tabs-mode nil)
(setq tab-stop 4)

;; Remove line continue character
(setf (cdr (assq 'continuation fringe-indicator-alist))
      '(nil nil) ;; no continuation indicators
      ;; '(nil right-curly-arrow) ;; right indicator only
      ;; '(left-curly-arrow nil) ;; left indicator only
      ;; '(left-curly-arrow right-curly-arrow) ;; default
      )

(setq auto-save-default nil)
(setq backup-directory-alist '(("" . "~/.Trash")))
(put 'dired-find-alternate-file 'disabled nil)
(setq confirm-kill-processes nil)

(defalias 'yes-or-no-p 'y-or-n-p)
(setq revert-without-query 1)

(use-package dired-single)
(use-package dired-open)
(setq dired-listing-switches "-alhgo --group-directories-first")

;; Close the compilation window if there was no error at all.
(setq compilation-exit-message-function
    (lambda (status code msg)
        ;; If M-x compile exists with a 0
        (when (and (eq status 'exit) (zerop code))
        ;; then bury the *compilation* buffer, so that C-x b doesn't go there
        (bury-buffer "*compilation*")
        ;; and return to whatever were looking at before
        (replace-buffer-in-windows "*compilation*"))
        ;; Always return the anticipated result of compilation-exit-message-function
    (cons msg code)))

(recentf-mode 1)
(setq recentf-max-menu 50
      recentf-max-saved-items 50)

(global-prettify-symbols-mode +1)
#+END_SRC

** Splash Screen
In my workflow, I don't find the splash screen useful, thus I prefer to supress it
and use the scratch buffer as the initial state.

#+BEGIN_SRC emacs-lisp
(setq-default inhibit-startup-screen t)
(setq inhibit-splash-screen t)
(setq inhibit-startup-message t)
(setq initial-scratch-message "")
#+END_SRC
