#+TITLE: Emacs Config
#+AUTHOR: Jay Morgan

* Executable Path
There are a few directories I would like to include in the environment =PATH=
variable. This includes anything binary install via Anaconda (sometimes it can
be convienant), and fzf (though...I really do use it, helm covers the
functionality pretty well).

#+BEGIN_SRC emacs-lisp
(defun my/add-to-exec (new-path)
  " Add the new-path (dir) to the PATH variable "
  (let ((new-path (expand-file-name new-path)))
  (setq exec-path (push new-path exec-path))
  (setenv "PATH" (format "%s:%s" (getenv "PATH") new-path))))

(my/add-to-exec "~/miniconda3/bin")
(my/add-to-exec "~/.fzf/bin")
#+END_SRC
* Setup Package Environment
** Initialisation
Over the time of configuring Emacs, I've found these variables help certain
packages from creating speed problems.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 100000000)
(setq read-process-output-max (* 1024 1024))
(setq evil-want-keybinding nil)
(setq x-wait-for-event-timeout nil)
#+END_SRC

A necessary configuration step of a customised Emacs setup is using melpa with
=package.el=.

#+BEGIN_SRC emacs-lisp
;; Manually installed plugins/packages
(add-to-list 'load-path (expand-file-name "~/.emacs.d/plugins/"))

;; Setup package.el to work with MELPA
(setq package-check-signature nil)
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
(add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))
(package-refresh-contents)
(package-initialize)
#+END_SRC

Most, if not all, packages are managed using the =use-package= plugin. This
should be the only plugin that is install in the "normal" fashion.

#+BEGIN_SRC emacs-lisp
;; Install function define a function to check if a package is
;; installed, if it not we can install it. From this, we may quickly
;; and easily install packages.
(defun my/check-and-install (pkg)
  (unless (package-installed-p pkg)
    (package-install pkg))
  (require pkg))

(my/check-and-install 'use-package)
;; Don't need a :ensure t in every package
(setq use-package-always-ensure t)
;; Makes it possible to install required binaries
(use-package use-package-ensure-system-package)
#+END_SRC

And quelpa

#+BEGIN_SRC emacs-lisp
(use-package quelpa)
(quelpa
 '(quelpa-use-package
   :fetcher git
   :url "https://github.com/quelpa/quelpa-use-package.git"))
(require 'quelpa-use-package)
#+END_SRC

** Programming Modes
It's a constant struggle to not learn every programming language ever!

Q: What are your favourite programming languages?
A: Clojure > Julia > C++ > Python

#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :init
  (use-package cider))

(use-package markdown-mode)
(use-package htmlize)
(use-package slime)
(use-package ess)

(use-package python-mode
  :config
  (use-package conda
    :init
    (conda-env-initialize-eshell)
    (setq conda-anaconda-home (expand-file-name "~/miniconda3/")
          conda-env-home-directory (expand-file-name "~/miniconda3/"))))

(use-package julia-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.jmd\\'" . markdown-mode))
  (use-package julia-repl
    :init
    (add-hook 'julia-mode-hook 'julia-repl-mode)
    (add-hook 'julia-repl-hook 'julia-repl-use-emacsclient)
    (setenv "JULIA_NUM_THREADS" "4")
    (setq julia-repl-executable-records
          '((default "julia")
            (master "/usr/bin/julia")
            (chemistry "ssh -t chemistry.me julia")))))
#+END_SRC

** LanguageServer

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :quelpa t
  :hook ((python-mode . lsp)
         (julia-mode . lsp)
         (ess-julia-mode . lsp)
         (sh-mode . lsp)
         (lsp-mode . lsp-enable-which-key-integration))
  :commands lsp
  :init
  (require 'lsp-clients)
  (quelpa '(lsp-julia :fetcher github
                      :repo "non-Jedi/lsp-julia"
                      :files (:defaults "languageserver")))
  (require 'lsp-julia)
  (setq lsp-diagnostics-modeline-scope :project)
  ;; (setq lsp-enable-links nil)
  ;; (setq lsp-modeline-code-actions-enable nil)
  ;; (setq lsp-lens-mode nil)
  ;; (setq lsp-idle-delay 1000)
  (setq lsp-completion-show-detail t
        lsp-completion-enable-additional-text-edit t)
  (add-hook 'lsp-managed-mode-hook 'lsp-diagnostics-modeline-mode)
  (add-hook 'lsp-managed-mode-hook 'lsp-modeline-code-actions-mode)
  (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration)
  ;; (use-package lsp-ui
  ;;   :config
  ;;   (setq lsp-ui-doc-enable t
  ;;         lsp-ui-doc-position 'at-point
  ;;         lsp-ui-sideline--code-actions nil
  ;;         lsp-ui-sideline-show-code-actions nil
  ;;         lsp-ui-peek-enable nil
  ;;         lsp-ui-peek-show-directory nil)
  ;;   (add-hook 'lsp-mode-hook 'lsp-ui-mode))
  (use-package helm-lsp
    :commands helm-lsp-workspace-symbol)
  (use-package company-lsp
    :requires company
    :config
    (push 'company-lsp company-backends)
    (setq company-lsp-async t)))
#+END_SRC

** Org-mode all the things!
Once I learnt about org-mode, it would always be tough to leave Emacs.

#+BEGIN_SRC emacs-lisp
(use-package org
  :after cider
  :ensure org-plus-contrib
  :init
  (setq org-startup-indented t)
  (add-hook 'org-mode-hook #'visual-line-mode)
  (add-hook 'org-mode-hook '(lambda () (set-fill-column 80)))
  (add-hook 'org-mode-hook #'auto-fill-mode)
  (require 'ob-clojure)
  (require 'cider)
  ;; extensions on org-mode
  (use-package ob-async)
  (use-package ox-pandoc)
  (use-package ox-gfm)
  (use-package org-ref
    :init
    (setq reftex-default-bibliography "~/Dropbox/Notes/Wiki/library.bib"
          org-ref-default-bibliography '("~/Dropbox/Notes/Wiki/library.bib")))
  (use-package helm-bibtex
    :init
    (setq bibtex-completion-bibliography "~/Dropbox/Notes/Wiki/library.bib"
          bibtex-completion-pdf-open-function 'org-open-file))
  (add-to-list 'org-latex-packages-alist '("" "tikz" t))
  (add-to-list 'org-latex-compilers "tectonic")
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
  (eval-after-load "preview" '(add-to-list 'preview-default-preamble "\\PreviewEnvironment{tikzpicture}" t))

  (require 'ox-latex)
  (add-to-list 'org-latex-classes
               '("thesis"
                 "\\documentclass{book}\n
                  \\usepackage{amssymb}
                  \\usepackage{gensymb}
                  \\usepackage[margin=1.5in]{geometry}
                  \\usepackage[T1]{fontenc}
                  \\usepackage{kpfonts,baskervald}
                  \\usepackage{units}
                  \\setlength{\\parskip}{11pt}
                  \\setlength{\\parindent}{0pt}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

  ;; set variables
  (setq org-format-latex-options (plist-put org-format-latex-options :scale 1.4)
        inferior-julia-program-name "/usr/bin/julia"
        org-confirm-babel-evaluate nil
        org-babel-clojure-backend 'cider
        org-fontify-done-headline t)
        org-todo-keywords '((sequence "TODO(t)" "WAIT(w)" "|" "DONE(d)"))

  ;; list of languages for org-mode to support
  (org-babel-do-load-languages 'org-babel-load-languages
                               '((shell . t)
                                 (emacs-lisp . t)
                                 (julia . t)
                                 (gnuplot . t)
                                 (dot . t))))
#+END_SRC

* Emacs Environment
* Email Client
I use mu4e and offlinemap to manage my email.

For the most part, the mu4e configuration is as default. The exception to this
is to use the =mail-add-attachment= function that doesn't prompt for the type of
file you're trying to attach. The second is =org-store-link= which allows me to
easily reference the email from my TODO list.

#+BEGIN_SRC emacs-lisp
(when (file-exists-p "/usr/local/share/emacs/site-lisp/mu4e/mu4e.el")
  (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e/")
  ;; define some custom keybindings
  (require 'mu4e)
  (define-key mu4e-compose-mode-map (kbd "C-c C-a") 'mail-add-attachment)
  (define-key mu4e-view-mode-map (kbd "C-c C-s") 'org-store-link)
  ;; load the configuration details
  (when (file-exists-p "~/.emacs.d/mu4e-init.el")
      (load "~/.emacs.d/mu4e-init.el")))

(use-package mu4e-alert
  :init
  (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display))
#+END_SRC

* Display & Load Settings
** GUI Elements
Keep the frame clean by removing all such GUI elements.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC
** Splash Screen
In my workflow, I don't find the splash screen useful, thus I prefer to supress
it and use the scratch buffer as the initial state.

#+BEGIN_SRC emacs-lisp
(setq-default inhibit-startup-screen t)
(setq inhibit-splash-screen t)
(setq inhibit-startup-message t)
(setq initial-scratch-message "")
#+END_SRC
